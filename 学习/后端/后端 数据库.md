## 1. 查询一个请求进行了哪些 SQL 查询

###### 方法一：在 Java 后端应用中开启 SQL 日志

常用的持久层框架 (例如 `MyBatis`)，都支持打印执行 SQL 的日志。可以通过在 `application.yaml` 中进行相关配置，来实现将 SQL 日志打印到控制台。

```yaml
mybatis-plus:  
  configuration:  
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
```

###### 方法二：数据库连接池监控

常用的数据库连接池或者 SQL 代理工具都提供 SQL 监控功能。

###### 方法三：使用数据库自身的 SQL 日志

以 MySQL 数据库为例，执行以下命令开启通用查询日志：

```SQL
SET GLOBAL general_log = 'ON';
-- 你可以选择将日志输出到文件或表，输出到表更容易查询
SET GLOBAL log_output = 'TABLE';
```

## 2. PostgreSQL 基本命令

###### 建立数据库连接

```Shell
psql -h [hostname] -p [port] -U [username] -d [database]
```

###### 其他常用命令

- 列出所有数据库: `\l`
- 连接数据库: `\c [database]`
- 列举数据库中所有的表: `\dt`
- 描述一个表: `\d [tablename]`

###### 查询所有外键

```SQL
SELECT
    ns.nspname as "模式 (Schema)",
    conrelid::regclass AS "表名 (Table)",
    conname AS "外键名称 (Constraint Name)",
    -- PG 12+ has a built-in function to get the definition
    -- For wider compatibility, we construct it manually
    pg_get_constraintdef(c.oid) AS "定义 (Definition)"
FROM
    pg_constraint c
JOIN
    pg_namespace ns ON c.connamespace = ns.oid
WHERE
    c.contype = 'f' -- 'f' 代表外键约束 (foreign key)
    AND ns.nspname NOT IN ('pg_catalog', 'information_schema', 'pg_toast'); -- 排除系统自带的模式

```

## 3. 视图

视图是一张**虚拟的、动态生成的表**。它本身不存储任何数据，而是像一个**窗口**，通过这个窗口，我们可以看到和操作一个或多个真实数据表（称为“基表”）中的数据。

视图允许用户通过始终如一的接口封装表的结构细节，这样可以避免表结构随着应用的进化而改变。

视图几乎可以用在任何可以使用表的地方。在其他视图基础上创建视图也并不少见。

对于一个复杂的查询：

```SQL
SELECT
    e.employee_name,
    e.age,
    d.department_name
FROM
    employees e
JOIN
    departments d ON e.department_id = d.id
WHERE
    e.salary > 5000;
```

如果这个查询需要被不同的人或在程序的不同地方反复使用，每次都写这么一长串SQL语句会很麻烦且容易出错。

这时，我们可以创建一个视图来封装这个逻辑：

```SQL
CREATE VIEW v_high_salary_employees AS
SELECT
    e.employee_name,
    e.age,
    d.department_name
FROM
    employees e
JOIN
    departments d ON e.department_id = d.id
WHERE
    e.salary > 5000;
```

视图创建好之后，任何人想进行这个查询，只需要执行一句非常简单的SQL：

```SQL
-- 使用视图，就像查询一张普通的表
SELECT * FROM v_high_salary_employees;
```

### 视图的作用

视图主要有三大作用：简化、安全和独立

###### 简化

正如之前举的例子，如果一个复杂查询的结果可预见性地会被经常使用，那么直接将这个复杂查询封装成为视图，可以极大地简化用户操作，同时降低 SQL 出错的风险。

###### 安全

如果对于一张表，我们只希望开放部分字段给某些用户，那么我们在这个表的基础上创建视图，然后把视图开放给用户。

###### 独立

数据库表的结构会随着业务发展而产生变化，假设有一张表 `t_user`，在业务发展后拆分为了两张表 `t_basic_user_info` 和 `t_contact_user_info`。为了不影响到业务代码中原有的 SQL 语句，我们可以创建一个名为 `t_user` 的视图来做适配，保证逻辑上的独立性。

## 4. 窗口函数与聚集函数

### 聚集函数

正如**聚集**所表示的那样，聚集函数的特点是**聚集数据**，它的结果行数通常会**小于**原有的行数。常见的函数都是聚集函数：`COUNT()`、`SUM()`、`AVG()`、`MAX()` 和 `MIN()`，并且它们通常会搭配 `GROUP BY` 使用。

计算每个部门的平均薪资和员工人数：

```SQL
Select
	department,
	Avg(salary) As avg_salary,
	Count(id) As employee_count
From
	employees
Group By
	department;
```

### 窗口函数

窗口函数是更加现代、更加强大的 SQL 特性。它的标志是 `Over()` 子句。其核心作用为：对与当前行相关的某些行进行计算，但不会改变原始表的行数。

语法特点：函数名称后面跟上 `Over()` 语句，`Over()` 语句内部可以包含：

- `Partition By`：定义窗口的范围，与 `Group By` 含义类似。
- `Order By`：定义窗口内部的排序规则。
- `Rows/Range`：进一步定义窗口内部的具体行范围。

显示每个员工信息、员工所在部门的平均薪资、该员工在部门的薪资排名：

```SQL
Select
	name,
	department,
	salary,
	Avg(salary) Over (Partition By department) As department_avg_salary,
	Rank() Over (Partition By department Order By salary Desc) As salary_rank
From
	employees;
```