# 模板元编程

## 1. 模板

### 1.1 基本语法

```cpp
template <typename T>
T twice(T x) {
    return x * 2;
}

std::string twice(std::string x) {
    return x + x;
}

int main() {
    int a = 5;
    double b = 3.14;
    std::string c = "Hello";

    int result1 = twice(a);
    double result2 = twice(b);
    std::string result3 = twice(c); 
    // twice("Hello");

    return 0;
}
```

上面是模板的基本语法，其中前两个 `twice` 会调用 `* 2` 版本的 `twice`，第三个则会调用 `x + x` 版本的。

不过值得注意的是，如果传入的是 `const char*`，例如 `twice("Hello")` 此时还是会调用 `* 2` 版本的 `twice`，从而产生编译错误。

### 1.2 默认参数

```cpp
template <typename T = int> 
T twice() {
    return 2;
}

int main() {
    int a = twice();
    return 0;
}
```

上面是为模板指定默认类型的语法。

### 1.3 其他类型参数

`typename` 关键字用来表示 `T` 是一个类型，其实除了类型，还有其他的可以作为模板的参数，例如整型。

```cpp
template <int N> void print(string str) {
    for (int i = 0; i < N; ++i) {
        cout << str << endl;
    }
}

int main() {
    print<4>("Hello, World!");
    print<3>("Hello, C++!");
    print<2>("Hello, Multithreading!");
    print<1>("Hello, Templates!");
}
```

这种模板参数和写在括号中的参数是有区别的，其主要区别在于，模板参数是编译期常量，也就是要在编译期确定它的值。这样的好处是有助于编译器优化，加快程序在运行期的效率。

假设对于 `print<0>("xx");`，编译器可能会直接忽略掉这个函数。对于 `print<1>("xx");`，编译器可能会去掉循环。

不过如果过度使用模板，编译期的负担将会很大，从而需要编译很久。

### 1.4 不要把模板函数的声明和定义分开

模板函数/类本身并不是真正的代码，而是编译器生成具体代码的“蓝图”。当你在代码中**使用模板**时（例如 `MyFunc<int>(42)`），编译器需要根据模板定义**当场生成针对 `int` 的代码**​（即实例化）。

所以不推荐将模板函数声明在头文件中，定义在 `.cpp` 文件中。

如果一定要分离，则需要在定义时，声明所有的可能情况：

```cpp
template <typename T> void MyFunc(T value) { // 定义在源文件
    // 实现代码
}

template void MyFunc<int>(int);
template void MyFunc<double>(double);
template void MyFunc<char>(char);
template void MyFunc<std::string>(std::string);
```

这无疑违反了开闭原则，每次新增一个可能性，都需要在定义处声明，与使用模板的初衷甚至都违背了。