# 包装项目

> 使用 JWT 令牌，用自定义拦截器完成用户认证，通过 ThreadLocal 来优化鉴权逻辑
> 1. `JWT` 令牌
	1. 使得服务器不用自己存大量的 Session 信息了，每次只需要验证令牌的签名是否有效、是否过期即可。这对于分布式、多服务器的系统来说特别好，任何一台服务器都能验证令牌，不需要共享 Session 数据。
> 2. 自定义拦截器
	2. 在自定义拦截器中验证 `JWT` 令牌，如果验证通过表明用户有效、否则需要重新登陆
> 3. `ThreadLocal`
	1. 将当前用户的 `ID` 信息直接保存在 `ThreadLocal` 中，避免了多次解析 `JWT`，或者需要拦截器向下传递用户 `ID`

> 使用工厂模式和策略模式实现布隆过滤器解决缓存穿透问题
> 1. 缓存穿透
> 	有大量请求查询缓存中不存在，并且数据库中也不存在的数据
> 2. 布隆过滤器
> 	可以高效地判断一个元素 "可能存在" 还是 "不可能存在" 于一个集合中。在系统启动时，把所有的待查询对象 `ID` 都添加到布隆过滤器中，当一个查询过来时，如果它判断为 "不可能存在"，则说明这个查询所查询的对象一定不在数据库中；如果它判断 "可能存在"，则进行正常的流程。

> 使用 Redis，采用一主两从 + 哨兵的集群方案，缓存营业状态、菜品分类等信息，解决了双写一致性问题
> 1. 一主两从三哨兵
> 	如果只使用一台 Redis 服务器，万一它宕机了，那么会对整个系统造成非常严重的影响，甚至无法正常提供服务。采用一主两从三哨兵的架构模式，可以缓解这种情况。
> 	主库：负责所有的写操作
> 	从库：实时地从主库中复制数据，保持和主库的数据一致。从库主要负责读操作，分担主库的压力
> 	哨兵：检查主库和从库是否在正常工作，如果发现主库宕机，哨兵会进行投票确认，然后从剩下的从库中按照一定的规则选举出一个新的主库，并通知其他的从库，以及应用程序。
> 2.  双写一致性
> 	在更新数据时，既要更新数据库，也要更新缓存，并且两个操作需要同时成功或者同时失败，这与缓存策略相关，一种常用的缓存策略如下：
> 	- 旁路缓存策略
> 		写操作：先更新数据库，然后**删除**缓存中对应的项
> 		读操作：先读缓存，若缓存不命中，就去读数据库，查到数据之后，再写回缓存

> 生成订单的时候，基于 Redis，使用防重 Token + Lua 脚本进行幂等性校验，防止重复提交
> 1. 防重 Token
> 	场景：想象一下，你在外卖 App 上选好了餐，点击“去支付”或“提交订单”。可能因为网络有点卡，你没看到成功提示，就不耐烦地又点了一下，甚至点了好几下。
> 	后果：如果系统没有做处理，你每点一次，服务器就可能真的去创建一次订单。结果就是你下了好几个一模一样的单，商家收到好几个单，你也可能被扣了好几次钱。这显然是不行的。
> 	目标：系统需要有能力识别出：虽然收到了多次创建同一个内容的请求，但实际上应该只执行一次创建操作。
> 	在用户进入最终订单的界面时，服务器先生成一个全局唯一、独一无二的字符串 (Token)，服务器会把这个 Token 存放到 Redis 中，并设置一个较短的过期时间。
> 	服务器会把这个 Token 也同样发送给用户的 App 或者网页端，用户端收到后，会在发送订单时把这个 Token 也一起发给服务器，这个 Token 就相当于本次提交订单操作的唯一标识符
> 2. Lua 脚本
> 	假设有两个请求几乎同时到达，它们都带着同一个 Token，那么就会在短期内连续地查询 Redis 是否包含有这个 Token。
> 	请求 A 检查 Redis，发现了 Token，在删除之前，请求 B 检查 Redis，也发现了 Token，这个时候，请求 B 也会去删除 Token。
> 	此时一个 Token 通过了两次校验，如果后端没有对 Redis 的删除结果进行处理的话，就会真的创建两次订单了。
> 	Redis 支持 Lua 脚本，并且 Redis 可以保证 Lua 脚本的执行是原子的，我们可以用一个 Lua 脚本来执行删除操作：

```lua
if redis.call('del', KEYS[1]) == 1 then
	return 1
else
	return 0
end
```

> 通过乐观锁解决超卖问题
> 1. 超卖
> 	超卖问题就是多个人购买同一件商品，如何避免卖出的数量超过库存的实际数量
> 2. 悲观锁
> 	**思路：** 非常谨慎，认为冲突很可能会发生。所以在操作数据之前，先**加锁**，阻止其他人访问。操作完成后再**解锁**。
> 	**缺点：** 如果很多人都要买这个热门商品，大家都要排队等锁，系统处理请求的速度（吞吐量）会大大降低，用户体验差。
> 3. 乐观锁
> 	 **思路：** 非常乐观，**假设**冲突一般不会发生。所以**不提前加锁**，让大家都去尝试操作。但是在**真正更新数据的时候**，会检查一下“在我读取数据之后，到我准备写入数据这段时间里，有没有其他人已经修改过这个数据了？”
> 	 **实现思路：** 乐观锁通常有两种实现思路，一种是基于版本号的实现方式 (Version) ，另一种则是使用 CAS 算法。
> 	 在数据库中添加一个 Version 字段，表示数据被更新的次数，当读取数据时，同时读入 Version 字段，在修改数据时，比较 Version 字段是否与数据库中现有的 Version 字段一致，如果一致则可以修改，反之，无法修改，此时需要重复上述操作，直到修改完成。
> 	 CAS 算法的全称是 Compare-And-Swap，表示比较并修改，它由三个要素：想要被修改的那个值的内存地址 V、预期旧值 A (相当于读取得到的 Version)、新值 B
> 	 CAS 算法的流程如下：
> 	 - 去内存地址 V 查看当前实际的值，比较实际的值与旧值 A 是否相等
> 	 - 如果相等，则进行交换操作，将内存位置的 V 的值更新为 B
> 	 - 否则什么也不做，并返回失败的信号
> 	 CAS 操作是一个**原子操作**。