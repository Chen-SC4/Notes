# Redis

## 1. 主从复制的实现原理

1. 第一次同步时，配置从服务器 `SLAVEOF` 主服务器，然后从服务器发送 `psync` 请求进行同步
2. 主服务器回复表示这次做全量同步
3. 主服务器在后台生成 `RDB` 文件，再发给从服务器
4. 主服务器把生成 `RDB` 文件期间进行的更新操作发给从服务器
5. 主从服务器之间建立起长连接，做增量同步

## 2. Redis 的应用

1. 作为缓存层，减小数据库的压力 (最常用)
2. 作为消息队列，利用 Redis 的 List 结构或者 Stream 结构
3. 作为分布式锁

## 3. Redis 为什么快

1. Redis 的数据存放在内存，访问速度比磁盘快
2. Redis 的数据结构为了高效进行了优化
3. Redis 单线程 + IO 多路复用，减少了线程切换的开销

## 4. Redis 的 Hash 结构

Redis 中的 Hash 以 Key - Value 的形式保存，它适合保存一些对象的信息，而且是容易发生变化的对象。不容易发生变化的对象可以选择以 JSON 的形式用 String 保存。

Redis 中维护了两个 HashTable 结构，第一个用来存储数据，第二个在 Rehash 的时候使用。HashTable 是非常高效的数据结构，内部维护一个 HashEntry 哈希桶数组，每个哈希桶下挂载数据链表。

当负载因子 (`负载因子 = 哈希表中元素的个数 / 哈希桶数组长度`) 大于等于 1 时，会考虑 Rehash，大于等于 5 时，会强制 Rehash。

Rehash 时，会把哈希表一的数据 Rehash 到哈希表二中，然后释放哈希表一，哈希表二成为哈希表一，然后再申请一个空的哈希表作为新的哈希表二。

Redis 采用渐进式 Rehash，当请求到来时，把请求对应的那个哈希桶中的元素进行 Rehash。

## 5. Redis 的过期删除策略

1. 维护一个过期字典，在请求一个 Key 时，如果这个 Key 已经过期，则删除这个 Key (惰性删除)
2. 定期随机抽查 Key，如果过期则删除 (定期删除)

Redis 会结合这两种删除策略。

## 6. Redis 的内存淘汰策略

1. 不淘汰，内存溢出之后，不会对查询报错，但是对写入报错
2. 淘汰有过期时间的 Key
	1. 随机淘汰
	2. LRU 淘汰 (近似 LRU)
	3. LFU 淘汰 (减少缓存污染)
	4. TTL 淘汰 (优先删除存活时间短的)
3. 淘汰所有 Key
	1. 随即淘汰
	2. LRU 淘汰 (近似 LRU)
	3. LFU 淘汰 (减少缓存污染)

## 7. Redis 分布式锁

一个简单的 Redis 分布式锁可以利用 Redis 的 SetIfNotExist 指令来实现 (SET NX)，再配合 PX 参数设置锁的过期时间。

与此同时，为了防止锁过期之后，任务还没有完成，还可以加上看门狗机制，来定期检查任务是否还占有锁，如果还占有，则延长锁的过期时间。

> 看门狗检查任务是否还占有锁，这个操作其实比较困难；通常的做法是，任务程序自身定期向看门狗发送心跳包，表示自己还在运行。看门狗收到心跳包后，就知道任务程序还在运行，就不会释放锁。

当解锁的时候，由于涉及到查询锁的使用状态和解锁这两个操作，所以为了使得这两个操作是原子的，需要使用 Lua 脚本。

---

## 8. 缓存雪崩、缓存击穿、缓存穿透

1. 缓存雪崩：大量 Key 同时过期，导致短期内大量请求访问数据库
	1. 在过期时间上加上随机偏移值
	2. 使用多级缓存
2. 缓存击穿：热点 Key 同时过期，导致短期内大量请求访问数据库
	1. 互斥锁，只允许少量请求访问数据库，并把结果缓存到 Redis 中
	2. 热点数据永不过期
3. 缓存穿透：非法访问数据库不存在的数据，导致大量请求缓存不命中，查询数据库
	1. 使用布隆过滤器
	2. 缓存查询结构为 null 的数据

## 9. Pipeline 和 MSet/MGet 的区别

由于网络延迟的存在，客户端如果一条指令一条指令地发送给 Redis 服务器，会造成大量的网络延迟。如果能把多条指令打包，一起发送给 Redis，然后 Redis 依次执行完，再把执行结果一起返回给客户端，那么就可以极大程度上减少网络延迟了。

MSet/MGet 类指令是 Redis 原生提供的批量处理指令，它们的速度比 Pipeline 更快，但是它们的功能也是比较有限的，Pipeline 可以使用任意的 Redis 指令。

## 10. Redis 集群

---

## Ex 1. 缓存与数据库的一致性问题

业界中最常用的解决方法是「旁路缓存」策略，即先更新数据库，然后再删除缓存。这种方法主要存在 3 个问题：

1. 在主从复制的架构中，多线程读取会读取到缓存的「旧值」
2. 如果第一个操作（更新数据库）执行成功，但是第二个操作（删除缓存）执行失败，那么就会导致缓存和数据库不一致
3. 在更新数据库和删除缓存这两个操作之间，仍然存在空窗期

首先可以解决的是第二个问题：使用一个消息队列来负责删除缓存的操作。需要删除时，先把删除信息放到消息队列中，然后如果消息队列成功执行了删除操作，那么这个删除信息就可以从消息队列中取出，否则重试。

然后解决的是第一个问题：使用「延迟双删」策略，在更新数据库之后，先立刻删除一次缓存，然后延迟一段时间，再次进行一次删除操作。只要把消息队列中的删除消息改成延迟的删除消息即可。