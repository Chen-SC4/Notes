# 项目介绍

## 1. 在线 OJ 判题系统

### 项目介绍

#### 项目背景

这个项目的目标是实现一个可以让用户在线提交代码、系统自动编译运行并判断结果是否正确的平台，类似于 LeetCode 的核心判题功能。

#### 架构演进

在项目初期，我采用单体架构，将所有的功能 (用户管理、题目管理、判题、题目提交、代码执行) 都放在一个 Spring Boot 项目中。但是在开发过程中，我发现代码执行这个环节很耗时，如果判题的请求过多，就会拖慢整个系统的响应速度。

为了解决这个问题，我将项目重构为了微服务架构。我将系统拆分成了 5 个模块：

1. 用户服务和题目服务：常规的业务逻辑，管理用户和管理题目
2. 判题服务：负责调用代码沙箱，并比对判题结果
3. 代码沙箱：负责隔离和安全地执行用户的代码
4. 网关服务：提供统一的 API 转发、聚合文档、全局跨域请求

#### 业务流程

1. 用户在前端提交代码，请求到网关服务
2. 网关服务把请求路由到题目服务
3. 题目服务进行一些基本的校验之后，把题目和请求封装成一个消息放到消息队列中
4. 判题服务从消息队列中取出消息，调用代码沙箱执行代码
5. 代码沙箱会在一个安全的环境中，编译、执行代码，获取执行结果
6. 判题服务将代码沙箱的执行结果与预期的结果进行比对，并将结果更新到数据库中

### 项目难点

1. 代码沙箱的设计 (安全性与资源控制)

从整体上，采用了工厂模式 + 策略模式，允许通过配置文件来切换不同的代码沙箱实现，例如 Docker 实现、第三方服务实现。目前项目采用的实现是通过 Docker 实现。每次请求的时候，都会创建一个 Docker 容器，然后执行代码。

安全性与资源控制：Docker 容器本身是一个相对独立的环境，并且 Docker 自带一些资源限制的机制，例如可以在启动容器的时候通过一些参数来限制内存或者 CPU 的使用。

2. 系统解耦与异步化

因为代码执行是一个比较耗时的操作。所以对它进行异步化处理。在项目中是通过引入了 RabbitMQ 作为消息队列来处理的。

3. 数据一致性

项目中采用的是保证最终一致性的策略，也就是：

- 当用户提交代码后，题目服务首先往数据库里插入一条判题记录，然后它的状态是「判题中」
- 然后题目服务将信息封装放到消息队列中
- 判题服务获得消息，调用代码沙箱执行代码
- 判题完成后，再把记录的状态修改为其他的状态，例如「通过」、「答案错误」等

## 2. RPC 框架

### 项目介绍

这个项目是实现了一个简单的 RPC 通信骨架，它使得调用远程服务能够像调用本地方法一样透明和便捷。

#### 项目模块

1. 消费者代理模块：框架需要为远程服务接口动态地生成代理对象。当调用方法的时候，调用的其实是代理对象的方法，代理对象会发送远程请求。
2. 注册中心：项目使用的是基于 Etcd 的注册中心。服务端启动的时候，会把自己提供的服务注册到注册中心上。
3. 服务提供者-服务注册：在服务提供方，当启动服务的时候，需要扫描需要暴露的服务，然后把服务注册到注册中心上
4. 负载均衡：当有多个服务的时候，框架会根据预先设置的负载均衡策略选择一个进行负载均衡
5. RPC 协议：自定义了 RPC 协议
6. 请求处理器：当服务提供者接收到 RPC 请求时，需要解析请求，找到对应的服务并通过反射执行
7. 容错机制
8. 启动器模块

#### 业务流程

1. 服务提供方将服务注册到注册中心
2. 服务消费方调用服务的时候，通过代理技术，发送远程请求
	1. 从注册中心获取到提供的服务列表
	2. 调用负载均衡策略选择一个服务提供者发送请求
3. 服务提供方解析请求，通过反射，调用对应的服务，将结果作为请求响应发送回给服务消费方

### 项目难点

#### RPC 协议

项目自定义了一个简单的通信协议，通过 Vert.X 的 recordParser 解决了 TCP 的粘包现象，通过 Spi 动态加载机制，设计了多种序列化器。

#### 服务动态发现与动态代理

使用 Etcd 作为服务注册中心，在消费端使用的 JDK 动态代理来创建接口的代理对象。项目虽然现在使用 Etcd 作为注册中心，它也支持通过 Spi 动态加载来支持其他的注册中心。

#### 框架可靠性

服务提供者将服务注册到注册中心后，需要定期发送心跳给注册中心，一旦被注册中心判断下线，Etcd 会自动将该实例的信息删除。

### 技术选型

#### Etcd

1. 租约机制，心跳检测
2. 支持集群部署，内部使用 Raft 算法支撑一致性
3. 支持服务发现和注册

#### Vert.x

1. 事件驱动，非阻塞 IO -> 高性能