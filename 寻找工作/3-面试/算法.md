# 算法

## 1. 一致性哈希

场景：有 3 台服务器 A、B 和 C，现在想要把 N 张图片缓存在这三台服务器上，为了最大限度地利用资源，我们希望 N 张图片能够尽量均匀地缓存在这三台服务器上。

使用普通哈希算法：

> 对于每张图片，计算它们的哈希值 `hash_i = Hash(Image_i)`，然后再用 `hash_i` 对服务器数量取模 `hash_i % 3` 得到的结果就是存放服务器的编号。对于同一张图片，它的哈希值是不会变的，所以它存放的服务器也是不会变的。
>
> 此时如果新加入了一台服务器，取模运算就变成了 `hash_i % 4`，此时，所有的图片对应的存放服务器都会发生改变，形成了缓存雪崩，容易使得数据库压力过大。

使用一致性哈希算法：

[ConsistentHash](../../全局静态资源/Excalidraw/ConsistentHash.md)

假设存在一个圆环，它上面有 $2^{32}$ 个槽位，首先对每个服务器进行哈希计算并对 $2^{32}$ 取模，这样每个服务器就在圆环上有一个唯一的位置。

然后对于每一张图片，同样计算它们的哈希值然后对 $2^{32}$ 取模，找到他们在圆环上的位置，然后从这个位置出发顺时针找到的第一个服务器就是存放这张图片的服务器。此时如果新加入了一台服务器，只有新服务器对应的位置和上一个服务器中间的图片所存放的位置会发生变化，不会影响到全部缓存。

解决了缓存雪崩的问题，此时还存在一个问题：如何保证图片能够均匀分布在 3 台服务器上呢？毕竟如果 3 台服务器的哈希值非常接近的话，图片的分布就会不均匀。

为了解决这个问题，我们可以引入虚拟节点，例如，对于服务器 A，引入虚拟节点 A1、A2、A3、...An。**随着虚拟节点的增多，图片均匀的概率也就会越来越大**。此时缓存一张图片的过程为：

1. 计算图片的哈希值，并将这个哈希值对 $2^{32}$ 取模，得到图片在圆环上的位置。
2. 从这个位置出发顺时针找到第一个虚拟节点。
3. 找到这个虚拟节点对应的服务器，存放这张图片。

```java
public ServiceMetaInfo select(Map<String, Object> requestParams, List<ServiceMetaInfo> serviceMetaInfoList) {  
	// 没有服务器
    if (serviceetaInfoList.isEmpty()) return null;  
    // 只有一台服务器
    if (serviceMetaInfoList.size() == 1) return serviceMetaInfoList.get(0);  
  
    // 构建虚拟节点  
    for (ServiceMetaInfo serviceMetaInfo : serviceMetaInfoList) {  
        for (int i = 0; i < VIRTUAL_NODE_NUM; ++i) {  
            int hash = this.getHash(serviceMetaInfo.getServiceAddress() + "#" + i);  
            virtualNodes.put(hash, serviceMetaInfo);  
        }  
    }

    int hash = this.getHash(requestParams);
    // 寻找第一个大于等于 hash 的虚拟节点  
    Map.Entry<Integer, ServiceMetaInfo> entry = virtualNodes.ceilingEntry(hash);  
    if (entry == null) {  
        entry = virtualNodes.firstEntry();  
    }
    return entry.getValue();  
}
```

## 2. Raft 一致性算法

[可视化 Raft 算法](https://thesecretlivesofdata.com/)

