# 消息队列

## 1. 核心术语

- 生产者：发送消息的程序
- 消费者：接收、处理消息的程序
- 消息：生产者和消费者之间传递的数据
- Broker：消息队列软件所在的服务器实体
- 队列：存储消息的容器
- 交换机 (Exchange)：接收生产者发送的消息，根据消息的类型、地址 (Routing Key)，以及自己的路由规则 (Binding) 把消息路由到一个或多个队列，是 RabbitMQ 的特有概念
- 主题 (Topic)：消息的逻辑分类，是以 Kafka 为代表的消息队列的概念
- 分区 (Partition)：用于将 Topic 进行分区，为了提高并发量，每个 Broker 上可以有一个或者多个 Partition
- 消费者组 (Consumer Group)：共同消费一个 Topic 的一组消费者，但是不同消费者可能消费不同的 Partition，Kafka 中的概念

## 2. 如何保证消息不丢失

### 生产者部分

- 事务机制

在 RabbitMQ 中，生产者可以开启事务模式，这样发送消息时如果出现异常，事务就会回滚，如果发送成功，则提交事务。

这种模式的缺点在于性能较低，在发送消息之后，需要同步等待发送结果。

- 确认机制

生产环境中常用的机制。确认机制可以类比 TCP 的确认机制。

### 消息队列部分

Broker 收到消息后，会将消息持久化到磁盘。

### 消费者部分

消费者处理完成之后，需要向 Broker 发送确认消息，表示消息已经被成功处理。如果没有发送确认消息，则 Broker 会重新投递消息。

## 3. 如何保证消息不重复

有三种常用方法：

1. 数据库的唯一性索引

生产者创建消息时，带上一个全局唯一的索引 ID；消费者处理消息时，先查询数据库中是否存在这个 ID，如果不存在，则插入并处理消息，反之说明消息重复

2. 状态机

在第一次处理之后，修改状态为已处理，之后再处理时，先查询状态，如果是已处理，则不再处理。(感觉也需要数据库的唯一性索引来保证状态的唯一性)

3. 外部数据库 (Redis)

还是为每条消息生成一个唯一 ID，只是现在不再用数据库存储 ID，而是用性能更高的 Redis 存储。


## 4. 如何保证消息的顺序性

1. 单一队列，一个队列对应一个消费者
2. 状态机 + 重试机制，如果消息有先后顺序 1 -> 2 -> 3，那么如果先执行到了 2，根据状态机判断 1 还没有执行，则可以先等一段时间，然后再重试 2
3. 分区，一个队列对应多个生产者，但是每个生产者只能向一个分区发送消息，这样就可以保证每个分区内的消息是有序的。
4. 顺序队列

## 5. 如何处理消息堆积

出现消息堆积，通常意味着生成速度远大于消费速度。首先应该寻找消费速度慢的原因，同时可以临时增加消费能力：

1. 增加消费者线程数量
2. 增加消费实例
3. 优化消费者逻辑

如果可以的话，可以对生产者进行限流，甚至丢弃不重要的消息或者延迟处理不重要的消息。