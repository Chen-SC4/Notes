# Zookeeper

## 1. 分布式锁

Zookeeper 支持创建**临时顺序**节点 `(-es)`，创建节点的特点是：

- 临时节点，在当前会话结束后，创建的节点会自动删除 (释放分布式锁)
- 顺序节点，节点编号是有序的

### 分布式锁的抢占流程

1. 客户端 A 加锁，此时 Zookeeper 内部会创建一个临时顺序节点 (例如 xxx-000001)，检查父节点下的所有子节点 (检查所有锁)，看看自己的编号是不是最小的，如果是则成功获取到锁
2. 客户端 B 加锁，此时 Zookeeper 内部会创建一个临时顺序节点 (例如 xxx-000002)，检查父节点下的所有子节点 (检查所有锁)，看看自己的编号是不是最小的，如果不是则注册监听删除事件，监听对象是上一个比自己小的节点 (不一定是最小)
3. 客户端 A 释放锁，触发客户端 B 的监听事件，客户端 B 重新判断，成功获取到锁

## 2. Zookeeper 集群选举

Zookeeper 不需要在配置文件中指定 Leader 和 Follower，但是 Zookeeper 集群在工作时存在三种角色：Leader、Follower 和 Observer，它们的职责如下：

- Leader：负责处理事务请求 (增删改操作)、负责集群内部各个服务器的调度
- Follower：负责处理非事务请求 (查询操作)、参与 Leader 选举投票
- Observer：负责处理非事务请求 (查询操作)

Zookeeper 集群选举主要根据两个字段进行选举：

- 服务器 ID (Server ID) ：用于唯一标识一个服务器，编号越大，在选举中的权重越大
- 事务 ID (ZxID)：用于标识一次服务器状态的变更，越大表示服务器中的数据越新，在选举中的权重越大

在选举中，如果某台服务器获得了超过半数的票数，那么它就是 Leader。假设下面依次启动 5 台 Zookeeper 服务器：

1. 启动 Server 1，启动后 1 会给自己投一票，然后将投票结果发给其他的服务器，由于其他服务器没有启动，所以 Server 1 始终处于 Looking 状态
2. 启动 Server 2，启动后 2 会给自己投一票，然后与 1 交换投票结果，由于 2 的 ID 大于 1，所以 2 获得了两票，但是一共有 5 台服务器，所以 2 的票数没有过半
3. 启动 Server 3，启动后经过投票和交换结果，Server 3 会获得 3 票，超过了一半，从而 Server 3 成为 Leader
4. 启动 Server 4、Server 5，由于选举已经结束，所以 Server 4 和 Server 5 都是 Follower

